Source Code Layout

## Use UTF-8 as the source file encoding. [link]

## Use two spaces per indentation level (aka soft tabs). No hard tabs. [link]

# bad - four spaces
def some_method
    do_something
end

# good
def some_method
  do_something
end

## Don't use ; to separate statements and expressions. As a corollary—use one expression per line. [link]

# bad
puts 'foobar'; # superfluous semicolon

puts 'foo'; puts 'bar' # two expressions on the same line

# good
puts 'foobar'

puts 'foo'
puts 'bar'

puts 'foo', 'bar' # this applies to puts in particular

## Prefer a single-line format for class definitions with no body. [link]

# bad
class FooError < StandardError
end

# okish
class FooError < StandardError; end

# good
FooError = Class.new(StandardError)

## Avoid single-line methods

# bad
def too_much; something; something_else; end

# good
def some_method
  body
end

Only exception to the rule If method have empty-body.

# good
def no_op; end

## Use spaces around operators, after commas, colons and semicolons. Whitespace might be (mostly) irrelevant to the Ruby interpreter, but its proper use is the key to writing easily readable code. [link]

sum = 1 + 2
a, b = 1, 2
class FooError < StandardError; end
There are a few exceptions. One is the exponent operator:

# bad
e = M * c ** 2

# good
e = M * c**2
Another exception is the slash in rational literals:

# bad
o_scale = 1 / 48r

# good
o_scale = 1/48r
Another exception is the safe navigation operator:

# bad
foo &. bar
foo &.bar
foo&. bar

# good
foo&.bar

## No spaces after (, [ or before ], ). Use spaces around { and before }. [link]

# bad
some( arg ).other
[ 1, 2, 3 ].each{|e| puts e}

# good
some(arg).other
[1, 2, 3].each { |e| puts e }

{ and } deserve a bit of clarification, since they are used for block and hash literals, as well as string interpolation
# good - space after { and before }
{ one: 1, two: 2 }

# good - no space after { and before }
{one: 1, two: 2}
With interpolated expressions, there should be no padded-spacing inside the braces.

# bad
"From: #{ user.first_name }, #{ user.last_name }"

# good
"From: #{user.first_name}, #{user.last_name}"

## No space after !

# bad
! something

# good
!something

## No space inside range literals.

# bad
1 .. 3
'a' ... 'z'

# good
1..3
'a'...'z'

## Indent when as deep as case

# bad
case
  when song.name == 'Misty'
    puts 'Not again!'
  when song.duration > 120
    puts 'Too long!'
  when Time.now.hour > 21
    puts "It's too late"
  else
    song.play
end

# good
case
when song.name == 'Misty'
  puts 'Not again!'
when song.duration > 120
  puts 'Too long!'
when Time.now.hour > 21
  puts "It's too late"
else
  song.play
end

## When assigning the result of a conditional expression to a variable, preserve the usual alignment of its branches.

# bad - pretty convoluted
kind = case year
when 1850..1889 then 'Blues'
end

result = if some_cond
  calc_something
end

# good - it's apparent what's going on
kind = case year
       when 1850..1889 then 'Blues'
       end

result = if some_cond
           calc_something
         end

# good (and a bit more width efficient)
kind =
  case year
  when 1850..1889 then 'Blues'
  end

result =
  if some_cond
    calc_something
  end

## Use empty lines between method definitions and also to break up methods into logical paragraphs internally

def some_method
  data = initialize(options)

  data.manipulate!

  data.result
end

def some_method
  result
end

## Don't use several empty lines in a row. [link]

# bad - It has two empty lines.
some_method


some_method

# good
some_method

some_method

## Use empty lines around access modifiers.

# bad
class Foo
  attr_reader :foo
  def foo
    # do something...
  end
end

# good
class Foo
  attr_reader :foo

  def foo
    # do something...
  end
end

## Don't use empty lines around method, class, module, block bodies.

# bad
class Foo

  def foo

    begin

      do_something do

        something

      end

    rescue

      something

    end

  end

end

# good
class Foo
  def foo
    begin
      do_something do
        something
      end
    rescue
      something
    end
  end
end

## Avoid comma after the last parameter in a method call, especially when the parameters are not on separate lines.

# bad
some_method(size, count, color, )

# good
some_method(size, count, color)

## Use spaces around the = operator when assigning default values to method parameters:

# bad
def some_method(arg1=:default, arg2=nil, arg3=[])
  # do something...
end

# good
def some_method(arg1 = :default, arg2 = nil, arg3 = [])
  # do something...
end

## Avoid line continuation \ where not required. In practice, avoid using line continuations for anything but string concatenation.

# bad
result = 1 - \
         2

# good (but still ugly as hell)
result = 1 \
         - 2

long_string = 'First part of the long string' \
              ' and second part of the long string'

## Align the parameters of a method call if they span more than one line. When aligning parameters is not appropriate due to line-length constraints, single indent for the lines after the first is also acceptable.

# starting point (line is too long)
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com', from: 'us@example.com', subject: 'Important message', body: source.text)
end

# bad (double indent)
def send_mail(source)
  Mailer.deliver(
      to: 'bob@example.com',
      from: 'us@example.com',
      subject: 'Important message',
      body: source.text)
end

# good
def send_mail(source)
  Mailer.deliver(to: 'bob@example.com',
                 from: 'us@example.com',
                 subject: 'Important message',
                 body: source.text)
end

# good (normal indent)
def send_mail(source)
  Mailer.deliver(
    to: 'bob@example.com',
    from: 'us@example.com',
    subject: 'Important message',
    body: source.text
  )
end

## Align the elements of array literals spanning multiple lines. [link

# bad - single indent
menu_item = %w[Spam Spam Spam Spam Spam Spam Spam Spam
  Baked beans Spam Spam Spam Spam Spam]

# good
menu_item = %w[
  Spam Spam Spam Spam Spam Spam Spam Spam
  Baked beans Spam Spam Spam Spam Spam
]

# good
menu_item =
  %w[Spam Spam Spam Spam Spam Spam Spam Spam
     Baked beans Spam Spam Spam Spam Spam]

## Add underscores to large numeric literals to improve their readability.

# bad - how many 0s are there?
num = 1000000

# good - much easier to parse for the human brain
num = 1_000_000

## Prefer lowercase letters for numeric literal prefixes. 0o for octal, 0x for hexadecimal and 0b for binary. Do not use 0d prefix for decimal literals.

# bad
num = 01234
num = 0O1234
num = 0X12AB

# good - easier to separate digits from the prefix
num = 0o1234
num = 0x12AB
num = 1234

## Limit lines to 80 characters
if you are using Sublime Editor. set property in setting

"wrap_width": 80
"word_wrap": true

## Avoid trailing whitespace
if you are using Sublime Editor. set property in setting
"trim_trailing_white_space_on_save": false

## End each file with a newline
if you are using Sublime Editor. set property in setting
  "ensure_newline_at_eof_on_save": true

## Don't use block comments.
# bad
=begin
comment line
another comment line
=end

# good
# comment line
# another comment line

### Syntax

##Use :: only to reference constants (this includes classes and modules) and constructors (like Array() or Nokogiri::HTML()).

## Do not use :: for regular method invocation.
# bad
SomeClass::some_method
some_object::some_method

# good
SomeClass.some_method
some_object.some_method
SomeModule::SomeClass::SOME_CONST
SomeModule::SomeClass()

## Do not use :: to define class methods.

# bad
class Foo
  def self::some_method
  end
end

# good
class Foo
  def self.some_method
  end
end

## Use def with parentheses when there are parameters. Omit the parentheses when the method doesn't accept any parameters.

# bad
def some_method()
  # body omitted
end

# good
def some_method
  # body omitted
end

# bad
def some_method_with_parameters param1, param2
  # body omitted
end

# good
def some_method_with_parameters(param1, param2)
  # body omitted
end

## Use parentheses around the arguments of method invocations, especially if the first argument begins with an open parenthesis (, as in f((3 + 2) + 1).

# bad
x = Math.sin y
# good
x = Math.sin(y)

# bad
array.delete e
# good
array.delete(e)

# bad
temperance = Person.new 'Temperance', 30
# good
temperance = Person.new('Temperance', 30)

## Always omit parentheses for Method calls with no arguments:

# bad
Kernel.exit!()
2.even?()
fork()
'test'.upcase()

# good
Kernel.exit!
2.even?
fork
'test'.upcase

## Always omit parentheses for Methods that are part of an internal DSL (e.g., Rake, Rails, RSpec):

# bad
validates(:name, presence: true)
# good
validates :name, presence: true

## Always omit parentheses for Methods that have "keyword" status in Ruby:

class Person
  # bad
  attr_reader(:name, :age)
  # good
  attr_reader :name, :age

  # body omitted
end

## Define optional arguments at the end of the list of arguments

here a=1 and b = 2 are optional argument

# bad
def some_method(a = 1, b = 2, c, d)
  puts "#{a}, #{b}, #{c}, #{d}"
end

some_method('w', 'x') # => '1, 2, w, x'
some_method('w', 'x', 'y') # => 'w, 2, x, y'
some_method('w', 'x', 'y', 'z') # => 'w, x, y, z'

# good
def some_method(c, d, a = 1, b = 2)
  puts "#{a}, #{b}, #{c}, #{d}"
end

some_method('w', 'x') # => '1, 2, w, x'
some_method('w', 'x', 'y') # => 'y, 2, w, x'
some_method('w', 'x', 'y', 'z') # => 'y, z, w, x'

## Use keyword arguments when passing boolean argument to a method.

# bad
def some_method(bar = false)
  puts bar
end

# bad - common hack before keyword args were introduced
def some_method(options = {})
  bar = options.fetch(:bar, false)
  puts bar
end

# good
def some_method(bar: false)
  puts bar
end

some_method            # => false
some_method(bar: true) # => true

## Prefer keyword arguments over optional arguments.

# bad
def some_method(a, b = 5, c = 1)
  # body omitted
end

# good
def some_method(a, b: 5, c: 1)
  # body omitted
end

## Use keyword arguments instead of option hashes.

# bad
def some_method(options = {})
  bar = options.fetch(:bar, false)
  puts bar
end

# good
def some_method(bar: false)
  puts bar
end

## Avoid the use of parallel assignment for defining variables. Parallel assignment is allowed when it is the return of a method call, used with the splat operator, or when used to swap variable assignment

# bad
a, b, c, d = 'foo', 'bar', 'baz', 'foobar'

# good
a = 'foo'
b = 'bar'
c = 'baz'
d = 'foobar'

# good - swapping variable assignment
# Swapping variable assignment is a special case because it will allow you to
# swap the values that are assigned to each variable.
a = 'foo'
b = 'bar'

a, b = b, a
puts a # => 'bar'
puts b # => 'foo'

# good - method return
def multi_return
  [1, 2]
end

first, second = multi_return

# good - use with splat
first, *list = [1, 2, 3, 4] # first => 1, list => [2, 3, 4]

hello_array = *'Hello' # => ["Hello"]

a = *(1..3) # => [1, 2, 3]


## Do not use for, unless you know exactly why
arr = [1, 2, 3]

# bad
for elem in arr do
  puts elem
end

# note that elem is accessible outside of the for loop
elem # => 3

# good
arr.each { |elem| puts elem }

# elem is not accessible outside each's block
elem # => NameError: undefined local variable or method `elem'

## Do not use then for multi-line if/unless.

# bad
if some_condition then
  # body omitted
end

# good
if some_condition
  # body omitted
end


## Always put the condition on the same line as the if/unless in a multi-line conditional.

# bad
if
  some_condition
  do_something_else
end

# good
if some_condition
  do_something
end

## Favor the ternary operator(?:) over if/then/else/end constructs. It's more common and obviously more concise.

# bad
result = if some_condition then something else something_else end

# good
result = some_condition ? something : something_else


## Use one expression per branch in a ternary operator. This also means that ternary operators must not be nested. Prefer if/else constructs in these cases.

# bad
some_condition ? (nested_condition ? nested_something : nested_something_else) : something_else

# good
if some_condition
  nested_condition ? nested_something : nested_something_else
else
  something_else
end

## Do not use if x; .... Use the ternary operator instead.

# bad
result = if some_condition; something else something_else end

# good
result = some_condition ? something : something_else

## Leverage the fact that if and case are expressions which return a result.

# bad
if condition
  result = x
else
  result = y
end

# good
result =
  if condition
    x
  else
    y
  end

## Use ! instead of not
# bad - parentheses are required because of op precedence
x = (not something)

# good
x = !something

## Avoid the use of !!

# bad
x = 'test'
# obscure nil check
if !!x
  # body omitted
end

# good
x = 'test'
if x
  # body omitted
end

## The and and or keywords are banned, always use && and || instead

# bad
# boolean expression
ok = got_needed_arguments and arguments_are_valid

# control flow
document.save or raise("Failed to save document!")

# good
# boolean expression
ok = got_needed_arguments && arguments_are_valid

# control flow
raise("Failed to save document!") unless document.save

# ok
# control flow
document.save || raise("Failed to save document!")

## Favor modifier if/unless usage when you have a single-line body. Another good alternative is the usage of control flow &&/||

# bad
if some_condition
  do_something
end

# good
do_something if some_condition

# another good option
some_condition && do_something

## Avoid modifier if/unless usage at the end of a non-trivial multi-line block.

# bad
10.times do
  # multi-line body omitted
end if some_condition

# good
if some_condition
  10.times do
    # multi-line body omitted
  end
end

## Avoid nested modifier if/unless/while/until usage. Favor &&/|| if appropriate.

# bad
do_something if other_condition if some_condition

# good
do_something if some_condition && other_condition

## Favor unless over if for negative conditions (or control flow ||)

# bad
do_something if !some_condition

# bad
do_something if not some_condition

# good
do_something unless some_condition

# another good option
some_condition || do_something

## Do not use unless with else. Rewrite these with the positive case first.

# bad
unless success?
  puts 'failure'
else
  puts 'success'
end

# good
if success?
  puts 'success'
else
  puts 'failure'
end

## Don't use parentheses around the condition of a control expression.

# bad
if (x > 10)
  # body omitted
end

# good
if x > 10
  # body omitted
end

## Do not use while/until condition do for multi-line while/until

# bad
while x > 5 do
  # body omitted
end

until x > 5 do
  # body omitted
end

# good
while x > 5
  # body omitted
end

until x > 5
  # body omitted
end

## Favor modifier while/until usage when you have a single-line body.

# bad
while some_condition
  do_something
end

# good
do_something while some_condition


## Favor until over while for negative conditions.

# bad
do_something while !some_condition

# good
do_something until some_condition

## Use Kernel#loop instead of while/until when you need an infinite loop.

# bad
while true
  do_something
end

until false
  do_something
end

# good
loop do
  do_something
end

## Omit the outer braces around an implicit options hash
# bad
user.set({ name: 'John', age: 45, permissions: { read: true } })

# good
user.set(name: 'John', age: 45, permissions: { read: true })

## Omit both the outer braces and parentheses for methods that are part of an internal DSL.

class Person < ActiveRecord::Base
  # bad
  validates(:name, { presence: true, length: { within: 1..10 } })

  # good
  validates :name, presence: true, length: { within: 1..10 }
end

## Use the proc invocation shorthand when the invoked method is the only operation of a block.

# bad
names.map { |name| name.upcase }

# good
names.map(&:upcase)

## Prefer {...} over do...end for single-line blocks. Avoid using {...} for multi-line blocks (multi-line chaining is always ugly). Always use do...end for "control flow" and "method definitions" (e.g. in Rakefiles and certain DSLs). Avoid do...end when chaining

names = %w[Bozhidar Steve Sarah]

# bad
names.each do |name|
  puts name
end

# good
names.each { |name| puts name }

# bad
names.select do |name|
  name.start_with?('S')
end.map { |name| name.upcase }

# good
names.select { |name| name.start_with?('S') }.map(&:upcase)

## Avoid return where not required for flow of control
# bad
def some_method(some_arr)
  return some_arr.size
end

# good
def some_method(some_arr)
  some_arr.size
end

## Avoid self where not required. (It is only required when calling a self write accessor, methods named after reserved words, or overloadable operators.

# bad
def ready?
  if self.last_reviewed_at > self.last_updated_at
    self.worker.update(self.content, self.options)
    self.status = :in_progress
  end
  self.status == :verified
end

# good
def ready?
  if last_reviewed_at > last_updated_at
    worker.update(content, options)
    self.status = :in_progress
  end
  status == :verified
end

## Don't use the return value of = (an assignment) in conditional expressions
# bad (+ a warning)
if v = array.grep(/foo/)
  do_something(v)
  # some code
end

# good
v = array.grep(/foo/)
if v
  do_something(v)
  # some code
end

## Use shorthand self assignment operators whenever applicable.

# bad
x = x + y
x = x * y
x = x**y
x = x / y
x = x || y
x = x && y

# good
x += y
x *= y
x **= y
x /= y
x ||= y
x &&= y

## Use ||= to initialize variables only if they're not already initialized

# bad
name = name ? name : 'Bozhidar'

# bad
name = 'Bozhidar' unless name

# good - set name to 'Bozhidar', only if it's nil or false
name ||= 'Bozhidar'

## Don't use ||= to initialize boolean variables.

# bad - would set enabled to true even if it was false
enabled ||= true

# good
enabled = true if enabled.nil?

## Use &&= to preprocess variables that may or may not exist. Using &&= will change the value only if it exists, removing the need to check its existence with if.

# bad
if something
  something = something.downcase
end

# bad
something = something ? something.downcase : nil

# ok
something = something.downcase if something

# good
something = something && something.downcase

# better
something &&= something.downcase

## Avoid explicit use of the case equality operator ===. As its name implies it is meant to be used implicitly by case expressions and outside of them it yields some pretty confusing code.

# bad
Array === something
(1..100) === 7
/something/ === some_string

# good
something.is_a?(Array)
(1..100).include?(7)
some_string.match?(/something/)

## Do not use eql? when using == will do. The stricter comparison semantics provided by eql? are rarely needed in practice

# bad - eql? is the same as == for strings
'ruby'.eql? some_str

# good
'ruby' == some_str
1.0.eql? x # eql? makes sense here if want to differentiate between Integer and Float 1

## Do not put a space between a method name and the opening parenthesis
# bad
f (3 + 2) + 1

# good
f(3 + 2) + 1

## Do not use nested method definitions

# bad
def foo(x)
  def bar(y)
    # body omitted
  end

  bar(x)
end

# good - the same as the previous, but no bar redefinition on every foo call
def bar(y)
  # body omitted
end

def foo(x)
  bar(x)
end

## Use the new lambda literal syntax for single line body blocks. Use the lambda method for multi-line blocks.

# bad
l = lambda { |a, b| a + b }
l.call(1, 2)

# correct, but looks extremely awkward
l = ->(a, b) do
  tmp = a * 7
  tmp * b / 50
end

# good
l = ->(a, b) { a + b }
l.call(1, 2)

l = lambda do |a, b|
  tmp = a * 7
  tmp * b / 50
end

## Prefer proc over Proc.new.

# bad
p = Proc.new { |n| puts n }

# good
p = proc { |n| puts n }

## Prefer proc.call() over proc[] or proc.() for both lambdas and procs
# bad - looks similar to Enumeration access
l = ->(v) { puts v }
l[1]

# also bad - uncommon syntax
l = ->(v) { puts v }
l.(1)

# good
l = ->(v) { puts v }
l.call(1)

## Favor the use of Array#join over the fairly cryptic Array#* with a string argument
# bad
%w[one two three] * ', '
# => 'one, two, three'

# good
%w[one two three].join(', ')
# => 'one, two, three'

## Use ranges or Comparable#between? instead of complex comparison logic when possible.

# bad
do_something if x >= 1000 && x <= 2000

# good
do_something if (1000..2000).include?(x)

# good
do_something if x.between?(1000, 2000)


## Favor the use of predicate methods to explicit comparisons with ==. Numeric comparisons are OK

# bad
if x % 2 == 0
end

if x % 2 == 1
end

if x == nil
end

# good
if x.even?
end

if x.odd?
end

if x.nil?
end

if x.zero?
end

if x == 0
end


## Don't do explicit non-nil checks unless you're dealing with boolean values

# bad
do_something if !something.nil?
do_something if something != nil

# good
do_something if something

# good - dealing with a boolean
def value_set?
  !@some_boolean.nil?
end

## Avoid the use of BEGIN blocks.

## Avoid the use of BEGIN blocks.

# bad
def compute_thing(thing)
  if thing[:foo]
    update_with_bar(thing[:foo])
    if thing[:foo][:bar]
      partial_compute(thing)
    else
      re_compute(thing)
    end
  end
end

# good
def compute_thing(thing)
  return unless thing[:foo]
  update_with_bar(thing[:foo])
  return re_compute(thing) unless thing[:foo][:bar]
  partial_compute(thing)
end

## Prefer next in loops instead of conditional blocks.

# bad
[0, 1, 2, 3].each do |item|
  if item > 1
    puts item
  end
end

# good
[0, 1, 2, 3].each do |item|
  next unless item > 1
  puts item
end

## Prefer map over collect, find over detect, select over find_all, reduce over inject and size over length

## Don't use count as a substitute for size. For Enumerable objects other than Array it will iterate the entire collection in order to determine its size

# bad
some_hash.count

# good
some_hash.size

## Use flat_map instead of map + flatten
  user.songs = ['a', ['b','c']]

# bad
all_songs = users.map(&:songs).flatten.uniq #=> ['a', 'b','c']

# good
all_songs = users.flat_map(&:songs).uniq #=> ['a', 'b','c']

## Prefer reverse_each to reverse.each because some classes that include Enumerable will provide an efficient implementation

# bad
array.reverse.each { ... }

# good
array.reverse_each { ... }

### Classes & Modules

## Use a consistent structure in your class definitions

class Person
  # extend and include go first
  extend SomeModule
  include AnotherModule

  # inner classes
  CustomError = Class.new(StandardError)

  # constants are next
  SOME_CONSTANT = 20

  # afterwards we have attribute macros
  attr_reader :name

  # followed by other macros (if any)
  validates :name

  # public class methods are next in line
  def self.some_method
  end

  # initialization goes between class methods and other instance methods
  def initialize
  end

  # followed by other public instance methods
  def some_method
  end

  # protected and private methods are grouped near the end
  protected

  def some_protected_method
  end

  private

  def some_private_method
  end
end

## Split multiple mixins into separate statements

# bad
class Person
  include Foo, Bar
end

# good
class Person
  # multiple mixins go in separate statements
  include Foo
  include Bar
end

## Don't nest multi-line classes within classes. Try to have such nested classes each in their own file in a folder named like the containing class

# bad

# foo.rb
class Foo
  class Bar
    # 30 methods inside
  end

  class Car
    # 20 methods inside
  end

  # 30 methods inside
end

# good

# foo.rb
class Foo
  # 30 methods inside
end

# foo/bar.rb
class Foo
  class Bar
    # 30 methods inside
  end
end

# foo/car.rb
class Foo
  class Car
    # 20 methods inside
  end
end

## Define (and reopen) namespaced classes and modules using explicit nesting. Using the scope resolution operator

module Utilities
  class Queue
  end
end

# bad
class Utilities::Store
  Module.nesting # => [Utilities::Store]

  def initialize
    # Refers to the top level ::Queue class because Utilities isn't in the
    # current nesting chain.
    @queue = Queue.new
  end
end

# good
module Utilities
  class WaitingList
    Module.nesting # => [Utilities::WaitingList, Utilities]

    def initialize
      @queue = Queue.new # Refers to Utilities::Queue
    end
  end
end

## Prefer modules to classes with only class methods. Classes should be used only when it makes sense to create instances out of them

# bad
class SomeClass
  def self.some_method
    # body omitted
  end

  def self.some_other_method
    # body omitted
  end
end

# good
module SomeModule
  module_function

  def some_method
    # body omitted
  end

  def some_other_method
    # body omitted
  end
end

## Favor the use of module_function over extend self when you want to turn a module's instance methods into class methods

# bad
module Utilities
  extend self

  def parse_something(string)
    # do stuff here
  end

  def other_utility_method(number, string)
    # do some more stuff
  end
end

# good
module Utilities
  module_function

  def parse_something(string)
    # do stuff here
  end

  def other_utility_method(number, string)
    # do some more stuff
  end
end


## Always supply a proper to_s method for classes that represent domain objects

class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def to_s
    "#{first_name} #{last_name}"
  end
end

## Use the attr family of functions to define trivial accessors or mutators

# bad
class Person
  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end

  def first_name
    @first_name
  end

  def last_name
    @last_name
  end
end

# good
class Person
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end

## For accessors and mutators, avoid prefixing method names with get_ and set_

# bad
class Person
  def get_name
    "#{@first_name} #{@last_name}"
  end

  def set_name(name)
    @first_name, @last_name = name.split(' ')
  end
end

# good
class Person
  def name
    "#{@first_name} #{@last_name}"
  end

  def name=(name)
    @first_name, @last_name = name.split(' ')
  end
end

## Avoid the use of attr. Use attr_reader and attr_accessor instead

# bad - creates a single attribute accessor (deprecated in Ruby 1.9)
attr :something, true
attr :one, :two, :three # behaves as attr_reader

# good
attr_accessor :something
attr_reader :one, :two, :three

## Don't extend an instance initialized by Struct.new

# bad
class Person < Struct.new(:first_name, :last_name)
end

# good
Person = Struct.new(:first_name, :last_name)

## Prefer duck-typing over inheritance

# bad
class Animal
  # abstract method
  def speak
  end
end

# extend superclass
class Duck < Animal
  def speak
    puts 'Quack! Quack'
  end
end

# extend superclass
class Dog < Animal
  def speak
    puts 'Bau! Bau!'
  end
end

# good
class Duck
  def speak
    puts 'Quack! Quack'
  end
end

class Dog
  def speak
    puts 'Bau! Bau!'
  end
end

## Avoid the usage of class (@@) variables due to their "nasty" behavior in inheritance

class Parent
  @@class_var = 'parent'

  def self.print_class_var
    puts @@class_var
  end
end

class Child < Parent
  @@class_var = 'child'
end

Parent.print_class_var # => will print 'child'

  "As you can see all the classes in a class hierarchy actually share one class variable. Class instance variables should usually be preferred over class variables.""


## Assign proper visibility levels to methods (private, protected) in accordance with their intended usage

## Indent the public, protected, and private methods as much as the method definitions they apply to. Leave one blank line above the visibility modifier and one blank line below in order to emphasize that it applies to all methods below it

Class SomeClass
  def public_method
    # some code
  end

  private

  def private_method
    # some code
  end

  def another_private_method
    # some code
  end
end


## Use def self.method to define class methods

class TestClass
  # bad
  def TestClass.some_method
    # body omitted
  end

  # good
  def self.some_other_method
    # body omitted
  end

  # Also possible and convenient when you
  # have to define many class methods.
  class << self
    def first_method
      # body omitted
    end

    def second_method_etc
      # body omitted
    end
  end
end

## Prefer alias when aliasing methods in lexical class scope

class Westerner
  def first_name
    @names.first
  end

  alias given_name first_name
end

## Always use alias_method when aliasing methods of modules, classes, or singleton classes at runtime

module Mononymous
  def self.included(other)
    other.class_eval { alias_method :full_name, :given_name }
  end
end

class Sting < Westerner
  include Mononymous
end

## When class (or module) methods call other such methods, omit the use of a leading self or own name followed by a . when calling other such methods

class TestClass
  # bad -- more work when class renamed/method moved
  def self.call(param1, param2)
    TestClass.new(param1).call(param2)
  end

  # bad -- more verbose than necessary
  def self.call(param1, param2)
    self.new(param1).call(param2)
  end

  # good
  def self.call(param1, param2)
    new(param1).call(param2)
  end

  # ...other methods...
end

### Exceptions

## Prefer raise over fail for exceptions
# bad
fail SomeException, 'message'

# good
raise SomeException, 'message'

## Don't specify RuntimeError explicitly in the two argument version of raise

# bad
raise RuntimeError, 'message'

# good - signals a RuntimeError by default
raise 'message'

## Do not return from an ensure block
# bad
def foo
  raise
ensure
  return 'very bad idea'
end

## Use implicit begin blocks where possible

# bad
def foo
  begin
    # main logic goes here
  rescue
    # failure handling goes here
  end
end

# good
def foo
  # main logic goes here
rescue
  # failure handling goes here
end

## Don't suppress exceptions

# bad
begin
  # an exception occurs here
rescue SomeError
  # the rescue clause does absolutely nothing
end

# bad
do_something rescue nil

## Avoid rescuing the Exception class.
# bad
begin
  # calls to exit and kill signals will be caught (except kill -9)
  exit
rescue Exception
  puts "you didn't really want to exit, right?"
  # exception handling
end

# good
begin
  # a blind rescue rescues from StandardError, not Exception as many
  # programmers assume.
rescue => e
  # exception handling
end

# also good
begin
  # an exception occurs here
rescue StandardError => e
  # exception handling
end


## Release external resources obtained by your program in an ensure block

f = File.open('testfile')
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close if f
end

### Collections

## Prefer literal array and hash creation notation

# bad
arr = Array.new
hash = Hash.new

# good
arr = []
arr = Array.new(10)
hash = {}
hash = Hash.new(0)

## Prefer %w to the literal array syntax when you need an array of words

# bad
STATES = ['draft', 'open', 'closed']

# good
STATES = %w[draft open closed]

## Prefer %i to the literal array syntax when you need an array of symbols
# bad
STATES = [:draft, :open, :closed]

# good
STATES = %i[draft open closed]

## Avoid the creation of huge gaps in arrays
arr = []
arr[100] = 1 # now you have an array with lots of nils

## When accessing the first or last element from an array, prefer first or last over [0] or [-1]

## Use Set instead of Array when dealing with unique elements

## Prefer symbols instead of strings as hash keys

# bad
hash = { 'one' => 1, 'two' => 2, 'three' => 3 }

# good
hash = { one: 1, two: 2, three: 3 }

## Don't mix the syntax

# bad
{ a: 1, 'b' => 2 }

# good
{ :a => 1, 'b' => 2 }

## Use Hash#key? instead of Hash#has_key? and Hash#value? instead of Hash#has_value?.

# bad
hash.has_key?(:test)
hash.has_value?(value)

# good
hash.key?(:test)
hash.value?(value)


## Use Hash#each_key instead of Hash#keys.each and Hash#each_value instead of Hash#values.each

## Introduce default values for hash keys via Hash#fetch as opposed to using custom logic.

batman = { name: 'Bruce Wayne', is_evil: false }

# bad - if we just use || operator with falsy value we won't get the expected result
batman[:is_evil] || true # => true

# good - fetch works correctly with falsy values
batman.fetch(:is_evil, true) # => false


## Use Hash#values_at when you need to retrieve several values consecutively from a hash.
# bad
email = data['email']
username = data['nickname']

# good
email, username = data.values_at('email', 'nickname')

### Integers

## Prefer to use ranges when generating random numbers instead of integers with offsets

# bad
rand(6) + 1

# good
rand(1..6)

### Strings

## Prefer string interpolation and string formatting instead of string concatenation:

# bad
email_with_name = user.name + ' <' + user.email + '>'

# good
email_with_name = "#{user.name} <#{user.email}>"

# good
email_with_name = format('%s <%s>', user.name, user.email)


## Avoid using String#+ when you need to construct large data chunks. Instead, use String#<<

# bad
html = ''
html += '<h1>Page title</h1>'

paragraphs.each do |paragraph|
  html += "<p>#{paragraph}</p>"
end

# good and also fast
html = ''
html << '<h1>Page title</h1>'

paragraphs.each do |paragraph|
  html << "<p>#{paragraph}</p>"
end

## Don't use String#gsub in scenarios in which you can use a faster and more specialized alternative

url = 'http://example.com'
str = 'lisp-case-rules'

# bad
url.gsub('http://', 'https://')
str.gsub('-', '_')

# good
url.sub('http://', 'https://')
str.tr('-', '_')


### Date & Time

## Prefer Time.zone.now over Time.new when retrieving the current system time

## Don't use DateTime unless you need to account for historical calendar reform—and if you do, explicitly specify the start argument to clearly state your intentions

# bad - uses DateTime for current time
DateTime.now

# good - uses Time for current time
Time.now

# bad - uses DateTime for modern date
DateTime.iso8601('2016-06-29')

# good - uses Date for modern date
Date.iso8601('2016-06-29')

# good - uses DateTime with start argument for historical date
DateTime.iso8601('1751-04-23', Date::ENGLAND)

### Regular Expressions

## Don't use regular expressions if you just need plain text search in string: string['text']

## For simple constructions you can use regexp directly through string index

match = string[/regexp/]             # get content of matched regexp
first_group = string[/text(grp)/, 1] # get content of captured group
string[/text (grp)/, 1] = 'replace'  # string => 'text replace'

## Be careful with ^ and $ as they match start/end of line, not string endings

string = "some injection\nusername"
string[/^username$/]   # matches
string[/\Ausername\z/] # doesn't match

##
##



### Naming

## Always use Name identifiers in English
# bad - identifier using non-ascii characters
заплата = 1_000

# bad - identifier is a Bulgarian word, written with Latin letters (instead of Cyrillic)
zaplata = 1_000

# good
salary = 1_000

## Use snake_case for symbols, methods and variables.

# bad
:'some symbol'
:SomeSymbol
:someSymbol

someVar = 5

def someMethod
  # some code
end

def SomeMethod
  # some code
end

# good
:some_symbol

some_var = 5

def some_method
  # some code
end


## Do not separate numbers from letters on symbols, methods and variables.

# bad
:some_sym_1

some_var_1 = 1

var_10  = 10

def some_method_1
  # some code
end

# good
:some_sym1

some_var1 = 1

var10    = 10

def some_method1
  # some code
end

## Use CamelCase for classes and modules

# bad
class Someclass
  # some code
end

class Some_Class
  # some code
end

class SomeXml
  # some code
end

class XmlSomething
  # some code
end

# good
class SomeClass
  # some code
end

class SomeXML
  # some code
end

class XMLSomething
  # some code
end

## Use snake_case for naming files, e.g. hello_world.rb

## Use snake_case for naming directories, e.g. lib/hello_world/hello_world.rb

## Aim to have just a single class/module per source file. Name the file name as the class/module, but replacing CamelCase with snake_case

## Use SCREAMING_SNAKE_CASE for other constants

# bad
SomeConst = 5

# good
SOME_CONST = 5

## The names of predicate methods (methods that return a boolean value) should end in a question mark.

  def tall?
    true
  end

## Avoid prefixing predicate methods with the auxiliary verbs such as is, does, or can

# bad
  def is_tall?
    true
  end

  def can_play_basketball?
    false
  end


# good
  def tall?
    true
  end

  def basketball_player?
    false
  end

## The names of potentially dangerous methods (i.e. methods that modify self or the arguments, exit! (doesn't run the finalizers like exit does), etc.) should end with an exclamation mark if there exists a safe version of that dangerous method.

# bad - there is no matching 'safe' method
class Person
  def update!
  end
end

# good
class Person
  def update
  end
end

# good
class Person
  def update!
  end

  def update
  end
end

### Comments

## Write self-documenting code and ignore the rest of this section

## If the how can be made self-documenting, but not the why, add a comment explaining the rationale behind the code

# bad

x = BuggyClass.something.dup

def compute_dependency_graph
  ...30 lines of recursive graph merging...
end

# good

# BuggyClass returns an internal object, so we have to dup it to modify it.
x = BuggyClass.something.dup

# This is algorithm 6.4(a) from Worf & Yar's _Amazing Graph Algorithms_ (2243).
def compute_dependency_graph
  ...30 lines of recursive graph merging...
end


## Write comments in English

## Use one space between the leading # character of the comment and the text of the comment

## Comments longer than a word are capitalized and use punctuation. Use one space after periods.

## Avoid superfluous comments.

# bad
counter += 1 # Increments counter by one.

## Keep existing comments up-to-date. An outdated comment is worse than no comment at all

## Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory.

##
